
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/victorabarros/termgifforge/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/victorabarros/termgifforge/internal/files/files.go (0.0%)</option>
				
				<option value="file2">github.com/victorabarros/termgifforge/internal/gif/gif.go (0.0%)</option>
				
				<option value="file3">github.com/victorabarros/termgifforge/internal/id/id.go (77.8%)</option>
				
				<option value="file4">github.com/victorabarros/termgifforge/internal/logs/logs.go (0.0%)</option>
				
				<option value="file5">github.com/victorabarros/termgifforge/pkg/models/gif_details.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"

        "net/http"
        "os"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/newrelic/go-agent/v3/integrations/logcontext-v2/nrlogrus"
        nrgin "github.com/newrelic/go-agent/v3/integrations/nrgin"
        "github.com/newrelic/go-agent/v3/newrelic"

        "github.com/sirupsen/logrus"
        "github.com/victorabarros/termgifforge/internal/files"
        "github.com/victorabarros/termgifforge/internal/gif"
        "github.com/victorabarros/termgifforge/internal/id"
        "github.com/victorabarros/termgifforge/internal/logs"
        "github.com/victorabarros/termgifforge/pkg/models"
)

var (
        port     = "80"
        version  = "0.1.3"
        homePage = "https://victor.barros.engineer/termgif"
        appName  = "termgifforge"

        outputCmdFormat = "Output %s"
        setCmds         = []string{
                "Set WindowBar Colorful",
                "Set FontSize 12",
                "Set Width 800",
                "Set Height 400",
        }

        newRelicApp *newrelic.Application
        logLevel    = logrus.InfoLevel // TODO move to env

        // GIFDetails is a map of GIFs and their statuses
        cache = models.NewGIFDetails()
)

type contextKey string

func init() <span class="cov0" title="0">{
        // create output directory if it doesn't exist; where GIFs are stored
        if err := files.CreateOutputDirectory(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        // TODO move to separate function
        // load cache mapper
        <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                gifs, err := files.ListGIFs()
                if err != nil </span><span class="cov0" title="0">{
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">for _, gif := range gifs </span><span class="cov0" title="0">{
                        name := gif.Name()
                        // remove .gif from name
                        id := name[:len(name)-4]
                        cache.SetStatus(id, models.GIFStatuses.Ready)
                }</span>
        }()

        // creating error and invalid GIFs if they don't exist
        <span class="cov0" title="0">if d, _ := cache.Get("error"); d.Status != models.GIFStatuses.Ready </span><span class="cov0" title="0">{
                createErrorGIF()
        }</span>
        <span class="cov0" title="0">if d, _ := cache.Get("invalid"); d.Status != models.GIFStatuses.Ready </span><span class="cov0" title="0">{
                createInvalidGIF()
        }</span>

        <span class="cov0" title="0">newRelicApp, err := newrelic.NewApplication(
                newrelic.ConfigAppName(appName),
                newrelic.ConfigLicense(os.Getenv("NEW_RELIC_LICENSE_KEY")),
                newrelic.ConfigAppLogForwardingEnabled(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                logs.Log.Fatalf("NewRelic initialization failed: %+2v", err)
        }</span>

        <span class="cov0" title="0">logs.InitLog(logLevel, nrlogrus.NewFormatter(newRelicApp, &amp;logrus.TextFormatter{}))</span>
}

func main() <span class="cov0" title="0">{
        r := gin.Default()
        r.Use(nrgin.Middleware(newRelicApp))

        err := newRelicApp.WaitForConnection(10 * time.Second)
        if nil != err </span><span class="cov0" title="0">{
                logs.Log.Fatalf("Failed to connect application %+2v", err)
        }</span>

        <span class="cov0" title="0">r.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, homePage)
        }</span>)

        <span class="cov0" title="0">r.GET("/ping", func(c *gin.Context) </span><span class="cov0" title="0">{
                gifs, err := files.ListGIFs()
                if err != nil </span><span class="cov0" title="0">{
                        logs.Log.Errorf("Fail to list GIFs %+2v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"message": "GIF in process"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "success", "nofGIFs": len(gifs), "version": version})</span>
        })

        <span class="cov0" title="0">rpcGroup := r.Group("/api/v1")
        rpcGroup.GET("/gif", createGIFHandler)
        rpcGroup.GET("/gif/:id", getGIFHandler)
        rpcGroup.GET("/mock", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("output/error.gif")
        }</span>)
        <span class="cov0" title="0">rpcGroup.DELETE("/internal-use/gif/:id", func(c *gin.Context) </span>{<span class="cov0" title="0">
                //TODO user files.EraseGIF
        }</span>)

        <span class="cov0" title="0">go files.Cleaner(&amp;cache)

        logs.Log.Infof("Starting app version %s in port %s", version, port)
        if err := http.ListenAndServe(":"+port, r); err != nil </span><span class="cov0" title="0">{
                logs.Log.Fatalf("Failed to start server: %+2v", err)
        }</span>
}

func getGIFHandler(c *gin.Context) <span class="cov0" title="0">{
        extras := logrus.Fields{
                "accept":          c.GetHeader("Accept"),
                "acceptEncoding":  c.GetHeader("Accept-Encoding"),
                "acceptLanguage":  c.GetHeader("Accept-Language"),
                "clientIP":        c.ClientIP(),
                "connection":      c.GetHeader("Connection"),
                "environment":     os.Getenv("ENVIRONMENT"),
                "host":            c.GetHeader("Host"),
                "origin":          c.GetHeader("Origin"),
                "referer":         c.GetHeader("Referer"),
                "userAgent":       c.GetHeader("User-Agent"),
                "xForwardedFor":   c.GetHeader("X-Forwarded-For"),
                "xForwardedProto": c.GetHeader("X-Forwarded-Proto"),
                "xRealIP":         c.GetHeader("X-Real-IP"),
        }

        logs.Log.WithFields(extras).Info("createGIFHandler")

        id := c.Param("id")
        logs.Log.WithFields(extras).Infof("id: %s", id)

        outGifPath := fmt.Sprintf("output/%s.gif", id)
        if d, ok := cache.Get(id); ok </span><span class="cov0" title="0">{
                if d.Status == models.GIFStatuses.Fail </span><span class="cov0" title="0">{
                        c.File("output/error.gif")
                        return
                }</span>
                <span class="cov0" title="0">if d.Status == models.GIFStatuses.Processing </span><span class="cov0" title="0">{
                        c.JSON(http.StatusAccepted, gin.H{"message": "GIF in process"})
                        return
                }</span>
                <span class="cov0" title="0">if d.Status == models.GIFStatuses.Ready </span><span class="cov0" title="0">{
                        cache.SetLastAccess(id, time.Now())
                        c.File(outGifPath)
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusNotFound, gin.H{"message": "GIF not found"})</span>
}

func createGIFHandler(c *gin.Context) <span class="cov0" title="0">{
        extras := logrus.Fields{
                "accept":          c.GetHeader("Accept"),
                "acceptEncoding":  c.GetHeader("Accept-Encoding"),
                "acceptLanguage":  c.GetHeader("Accept-Language"),
                "clientIP":        c.ClientIP(),
                "connection":      c.GetHeader("Connection"),
                "environment":     os.Getenv("ENVIRONMENT"),
                "host":            c.GetHeader("Host"),
                "origin":          c.GetHeader("Origin"),
                "referer":         c.GetHeader("Referer"),
                "userAgent":       c.GetHeader("User-Agent"),
                "xForwardedFor":   c.GetHeader("X-Forwarded-For"),
                "xForwardedProto": c.GetHeader("X-Forwarded-Proto"),
                "xRealIP":         c.GetHeader("X-Real-IP"),
        }

        logs.Log.WithFields(extras).Info("createGIFHandler")

        cmdsInputStr := c.Query("commands")
        cmdInput := []string{}
        if err := json.Unmarshal([]byte(cmdsInputStr), &amp;cmdInput); err != nil </span><span class="cov0" title="0">{
                logs.Log.Errorf("Error trying to serialize object: %+2v", err)
                c.File("output/invalid.gif")
                return
        }</span>

        <span class="cov0" title="0">id := id.NewUUUIDAsString(cmdsInputStr)
        outGifPath := fmt.Sprintf("output/%s.gif", id)
        if d, ok := cache.Get(id); ok </span><span class="cov0" title="0">{
                if d.Status == models.GIFStatuses.Fail </span><span class="cov0" title="0">{
                        c.File("output/error.gif")
                        return
                }</span>
                <span class="cov0" title="0">if d.Status == models.GIFStatuses.Processing </span><span class="cov0" title="0">{
                        c.JSON(http.StatusAccepted, gin.H{"message": "GIF in process"})
                        return
                }</span>
                <span class="cov0" title="0">if d.Status == models.GIFStatuses.Ready </span><span class="cov0" title="0">{
                        cache.SetLastAccess(id, time.Now())
                        c.File(outGifPath)
                        return
                }</span>
        }

        <span class="cov0" title="0">cmds := append([]string{fmt.Sprintf(outputCmdFormat, outGifPath)}, setCmds...)
        cmds = append(cmds, cmdInput...)

        go processGIF(id, cmds)

        c.JSON(http.StatusAccepted, gin.H{"message": "GIF in process"})</span>
}

func processGIF(id string, cmds []string) error <span class="cov0" title="0">{
        outTapePath := fmt.Sprintf("output/%s.tape", id)
        cache.SetStatus(id, models.GIFStatuses.Processing)

        if err := gif.WriteTape(cmds, outTapePath); err != nil </span><span class="cov0" title="0">{
                logs.Log.Errorf("Error writing to file: %+2v", err)
                cache.SetStatus(id, models.GIFStatuses.Fail)
                return err
        }</span>
        <span class="cov0" title="0">defer os.Remove(outTapePath)

        if err := gif.ExecVHS(outTapePath); err != nil </span><span class="cov0" title="0">{
                logs.Log.Errorf("Error running command: %+2v", err)
                cache.SetStatus(id, models.GIFStatuses.Fail)
                return err
        }</span>

        <span class="cov0" title="0">cache.SetStatus(id, models.GIFStatuses.Ready)

        logs.Log.Infof("GIF Created id %s", id)
        return nil</span>
}

func createErrorGIF() error <span class="cov0" title="0">{
        cmdInput := []string{
                "Type \"Sorry, it was not possible create your GIF. =/\"",
                "Sleep 6s",
        }

        id := "error"
        outGifPath := fmt.Sprintf("output/%s.gif", id)

        cmds := append([]string{fmt.Sprintf("Output %s", outGifPath)}, setCmds...)
        cmds = append(cmds, cmdInput...)

        go processGIF(id, cmds)

        return nil
}</span>

func createInvalidGIF() error <span class="cov0" title="0">{
        cmdInput := []string{
                "Type \"Invalid request...\"",
                "Sleep 6s",
        }

        id := "invalid"
        outGifPath := fmt.Sprintf("output/%s.gif", id)

        cmds := append([]string{fmt.Sprintf("Output %s", outGifPath)}, setCmds...)
        cmds = append(cmds, cmdInput...)

        go processGIF(id, cmds)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package files

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/victorabarros/termgifforge/internal/logs"
        "github.com/victorabarros/termgifforge/pkg/models"
)

var (
        sleepLapse        = 10 * time.Minute
        defaultLastAccess = time.Now().Add(-12 * time.Hour)
        ttl               = -24 * time.Hour
)

// CreateOutputDirectory creates ./output directory if it doesn't exist
func CreateOutputDirectory() error <span class="cov0" title="0">{
        dirName := "output"

        // Check if the directory exists
        _, err := os.Stat(dirName)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Create the directory if it doesn't exist
                        perm := os.FileMode(0755)
                        if err := os.Mkdir(dirName, perm); err != nil </span><span class="cov0" title="0">{
                                logs.Log.Errorf("Failed to create directory %s: %+2v", dirName, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">logs.Log.Errorf("Fail to check if Directory '%s' exists: %+2v", dirName, err)
                return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ListGIFs returns slice of GIFs as os.DirEntry from ./output directory
func ListGIFs() ([]os.DirEntry, error) <span class="cov0" title="0">{
        dirName := "output"
        var gifFiles []os.DirEntry
        files, err := os.ReadDir(dirName)
        if err != nil </span><span class="cov0" title="0">{
                logs.Log.Fatalf("Failed to read directory %s: %+2v", dirName, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; filepath.Ext(file.Name()) == ".gif" </span><span class="cov0" title="0">{
                        gifFiles = append(gifFiles, file)
                }</span>
        }

        <span class="cov0" title="0">return gifFiles, nil</span>
}

// Cleaner is a worker that every hour removes GIFs older than TTL
func Cleaner(details *models.GIFDetails) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(sleepLapse)
                logs.Log.Debug("Init cleaner")
                for id := range details.GIF </span><span class="cov0" title="0">{
                        EraseGIF(id, details)
                }</span>

                // TODO check if volume of GIF is higher than 90% of the DISK. If so, erase quarter of the oldest
        }
}

// EraseGIF clean GIF by id
func EraseGIF(id string, details *models.GIFDetails) <span class="cov0" title="0">{
        if id == "waiting" || id == "error" || id == "invalid" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d, ok := details.Get(id)
        if !ok </span><span class="cov0" title="0">{
                // 12 hour default last access
                details.SetLastAccess(id, defaultLastAccess)
                return
        }</span>

        // Only remove if last access is older than TTL
        <span class="cov0" title="0">if d.LastAccess.Before(time.Now().Add(ttl)) </span><span class="cov0" title="0">{
                path := fmt.Sprintf("output/%s.gif", id)
                logs.Log.Infof("removing GIF %s", path)
                if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                        logs.Log.Errorf("fail to remove '%s': %+2v\n", path, err)
                        return
                }</span>

                <span class="cov0" title="0">details.Del(id)</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package gif

import (
        "os"
        "os/exec"
)

// WriteTape creates .tape file and write commands to it
func WriteTape(cmds []string, filePath string) error <span class="cov0" title="0">{
        // Remove old file
        os.Remove(filePath)

        // Create or overwrite the file
        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close() // Ensure the file is closed when the function exits

        // Write each command to the file
        for _, cmd := range cmds </span><span class="cov0" title="0">{
                _, err = file.WriteString(cmd + "\n")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ExecVHS runs VHS to create GIF from .tape file
func ExecVHS(filePath string) error <span class="cov0" title="0">{
        cmd := exec.Command("vhs", filePath)

        // Set the output to the current process's stdout and stderr
        if os.Getenv("ENVIRONMENT") == "local" </span><span class="cov0" title="0">{
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
        }</span>

        // Run the command
        <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package id

import (
        "crypto/md5"
        "encoding/hex"

        "github.com/google/uuid"
        "github.com/victorabarros/termgifforge/internal/logs"
)

// NewUUUIDAsString create deterministic UUUID
func NewUUUIDAsString(input string) string <span class="cov10" title="2">{
        // calculate the MD5 hash of the
        md5hash := md5.New()
        _, err := md5hash.Write([]byte(input))
        if err != nil </span><span class="cov0" title="0">{
                logs.Log.Fatalf("Failed to write MD5 hash: %+2v", err)
        }</span>

        // convert the hash value to a string
        <span class="cov10" title="2">md5string := hex.EncodeToString(md5hash.Sum(nil))

        // generate the UUID from the
        uuid, err := uuid.FromBytes([]byte(md5string[0:16]))
        if err != nil </span><span class="cov0" title="0">{
                logs.Log.Fatalf("Failed to generate UUID: %+2v", err)
        }</span>

        <span class="cov10" title="2">return uuid.String()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package logs

import (
        "github.com/sirupsen/logrus"
)

var Log *logrus.Logger

func InitLog(level logrus.Level, formatter logrus.Formatter) <span class="cov0" title="0">{
        Log = logrus.New()
        Log.SetLevel(level)
        Log.SetFormatter(formatter)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "sync"
        "time"
)

type GIFStatus string

var (
        GIFStatuses = struct {
                Fail       GIFStatus
                Processing GIFStatus
                Ready      GIFStatus
        }{
                Fail:       GIFStatus("Fail"),
                Processing: GIFStatus("Processing"),
                Ready:      GIFStatus("Ready"),
        }
)

// TODO rename to GIFState
type GIFDetail struct {
        Status     GIFStatus
        LastAccess time.Time
}

type GIFDetails struct {
        GIF   map[string]GIFDetail
        Mutex *sync.Mutex
}

func (d *GIFDetails) Get(id string) (GIFDetail, bool) <span class="cov0" title="0">{
        d.Mutex.Lock()
        defer d.Mutex.Unlock()
        val, ok := d.GIF[id]
        return val, ok
}</span>

func (d *GIFDetails) SetStatus(id string, val GIFStatus) <span class="cov0" title="0">{
        if d.GIF == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d.Mutex.Lock()
        defer d.Mutex.Unlock()

        detail, ok := d.GIF[id]
        if !ok </span><span class="cov0" title="0">{
                d.GIF[id] = GIFDetail{
                        Status:     val,
                        LastAccess: time.Now(),
                }
                return
        }</span>

        <span class="cov0" title="0">d.GIF[id] = GIFDetail{
                Status:     val,
                LastAccess: detail.LastAccess,
        }</span>
}

func (d *GIFDetails) SetLastAccess(id string, val time.Time) <span class="cov0" title="0">{
        if d.GIF == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">d.Mutex.Lock()
        defer d.Mutex.Unlock()

        detail, ok := d.GIF[id]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.GIF[id] = GIFDetail{
                Status:     detail.Status,
                LastAccess: val,
        }</span>
}

func (d *GIFDetails) Del(id string) <span class="cov0" title="0">{
        d.Mutex.Lock()
        defer d.Mutex.Unlock()
        delete(d.GIF, id)
}</span>

func NewGIFDetails() GIFDetails <span class="cov0" title="0">{
        return GIFDetails{
                GIF:   map[string]GIFDetail{},
                Mutex: &amp;sync.Mutex{},
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
